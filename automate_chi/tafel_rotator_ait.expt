#!/usr/bin/env ruby

require 'logger' #Must be required before automate_chi.rb!
#$log_file = File.new('Z:\Labs\noceracode\automate_chi\test.log', 'w')
#$log_file = File.new('C:\Documents and Settings\Electrochemistry\My Documents\Dropbox\Electrochemistry\Mike\01-04-2012\tafel8\tafel_cp.log', 'w')
$log_file = File.new('C:\Users\Pot760Dblack\Dropbox\Electrochemistry\Mike\03-21-2012\03rotator\rotator.log', 'w')
$log_file.sync = true #do not buffer
$log = Logger.new($log_file)
#$log = Logger.new(STDOUT)
$log.level = Logger::DEBUG

require './automate_chi.rb'
require '../usbnetpower8800/usbnetpower8800.rb'
@stir_plate = USBNetPower8800.new
require '../pH-vwr/pH-vwr.rb'
@pH_meter = PHVWR.new(4) #COM5

def run_rotator_ait
  $log.info '-------------------------------------'
  begin
    $log.info 'Running rotator experiment with filename: %s' % @save_filename
    es = EchemSoftware.new
    es.setup_manual_ir_compensation(@ir_comp)
    es.setup_amperometric_it_curve(@init_e, @sample_interval, @run_time, 
                                   0, 3, @sensitivity) 
	#A quirk with the software is that RDE settings MUST be called after a
	#technique. If called before, then the rpm will be reset to zero once
	#a technique settings are filled in.
	es.setup_rotating_disk_electrode(@rde_rpm)
	Thread.new {
	  @stir_plate.on
	  sleep(@stir_time)
	  @stir_plate.off
	}
    es.run(@status_check_interval, @status_max_runtime)
    es.save_as(@save_filename)
	
	#Get pH at final point
	m = @pH_meter.measure
	begin
	  $log.info 'pH: %f' % m['pH']
	  $log.info 'Temp: %f' % m['temp']
	rescue TypeError
	  $log.info 'pH meter returned nil'
	end
  rescue RuntimeError
    $log.error 'RuntimeError: Retrying experiment...'
    #Getting here means that the software has crashed. So let's try to restart
    #it again.
    es.kill
    $log.info 'Killing program and sleeping for a bit...'
    sleep(60) #1 minutes to let instrument rest
    retry
  ensure
    if es #when we have errors, es is automatically GC'ed and set to nil.
      $log.info 'Killing program through ensure...'
      es.kill
      es = nil
    end
  end
  $log.info '-------------------------------------'
  $log.info
  $log_file.flush #since .sync doesn't work for some reason
  print '.',
end

#Experiment variables
@stir_time = 30 #sec. On highest rot, we double the stir time.
@collect_time = 60 #sec
#The sensitivity must be specified as 1e-n where n = [1, 12], because that
#is what the potentiostat can handle.
@sensitivity = 1e-5
@sample_interval = 0.5 #sec
@ir_comp = 10 #ohm

#The following is for our own purposes for defining the potential range and step
@potential_range = (0.25..0.37) #V
#@step = (@potential_range.last - @potential_range.first) / 12.0
@step = 0.02 #V
@rotation_velocities = [2500, 1600, 1225, 900, 625] #rpm




#We run from high potential to low potential
for pass in 1..2
  potentials = @potential_range.step(@step).to_a.map {|x| x.round(3)}
  potentials.reverse! #for from high to low
  $log.info('Potentials: %s' % potentials.to_s)
  
  #For each potential, we loop through specified rotation velocities.
  potentials.each_with_index do |p, i|
    @init_e = p
    #Dynamic sensitivity mod
	@sensitivity = 1e-5 if p <= 0.37
    @sensitivity = 1e-6 if p <= 0.27
	
    @rotation_velocities.each do |rpm|
	  #next if p == 0.31 and rpm == 2500 #continuing from crash
	  
	  @run_time = @stir_time + @collect_time 
	  @status_check_interval = (@run_time + 10) / 2 #sec
      #When our runtime exceeds the maximum runtime given below, we assume the experi
      #has crashed and exit from loop.
      @status_max_runtime = @run_time + 20 #sec
	  
      @rde_rpm = rpm

      @save_filename  = '%02ip_%03i_%irpm.bin' % [pass, p * 100, rpm]
      run_rotator_ait
    end
  end
end

#Turn off RDE
begin
  $log.info 'Running rotator experiment with filename: %s' % @save_filename
  es = EchemSoftware.new
  es.setup_rotating_disk_electrode(0)
ensure
  if es #when we have errors, es is automatically GC'ed and set to nil.
    $log.info 'Killing program through ensure...'
    es.kill
    es = nil
  end
end

@stir_plate.close
